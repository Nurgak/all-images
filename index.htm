<!DOCTYPE html>
<html>
<head>
<title>All Images</title>
<style>
html, body
{
    margin: 0;
    background-color: whitesmoke;
}
canvas
{
    width: 100%;
    image-rendering: pixelated;
    background-color: black;
}
.content
{
    width: 800px;
    margin: auto;
    background-color: white;
    padding: 1em;
}
.image
{
    position: relative;
    float: right;
    width: 50%;
}
.configuration
{
    width: 50%;
}
.source
{
    clear: both;
}
</style>
<script type="text/javascript">
let canvas, context, elements, bits, channels, imagedata, maxindex;
let time_iteration_average = 0, time_remaining, time_iteration_start, time_iteration_end, time_runtime_start, duration_runtime = 0;

let running = false;
let imageindex = BigInt(0);
let time_runtime = 0;

function parse_index(imagedata, imageindex, bits, channels)
{
    let x, y, pixelindex, colorindex, gray;
    let mask = BigInt((2n ** BigInt(bits)) - 1n);

    for(y = 0; y < canvas.height; ++y)
    {
        for(x = 0; x < canvas.width; ++x)
        {
            if(channels == 1)
            {
                pixelindex = (y * canvas.width + x) * 4;
                colorindex = BigInt(y * canvas.width + x);
                gray = 0xff * Number(((imageindex >> (BigInt(bits) * colorindex)) & mask) / mask);
                imagedata.data[pixelindex+0] = gray;
                imagedata.data[pixelindex+1] = gray;
                imagedata.data[pixelindex+2] = gray;
                imagedata.data[pixelindex+3] = 0xff;
            }
            else
            {
                pixelindex = (y * canvas.width + x) * 4;
                colorindex = BigInt(y * canvas.width + x) * 3n;
                imagedata.data[pixelindex+0] = 0xff * Number(((imageindex >> (BigInt(bits) * (colorindex + 0n))) & mask) / mask);
                imagedata.data[pixelindex+1] = 0xff * Number(((imageindex >> (BigInt(bits) * (colorindex + 1n))) & mask) / mask);
                imagedata.data[pixelindex+2] = 0xff * Number(((imageindex >> (BigInt(bits) * (colorindex + 2n))) & mask) / mask);
                imagedata.data[pixelindex+3] = 0xff;
            }
        }
    }
}

function time_suffix(milliseconds)
{
    const suffixes = {
        "milliseconds": 1000,
        "seconds": 60,
        "minutes": 60,
        "hours": 24,
        "days": 7,
        "weeks": 4,
        "months": 52,
        "years": 10,
        "decades": 10,
        "centuries": 10,
        "millenia": 1,
    };

    for(let suffix in suffixes)
    {
        if((milliseconds / suffixes[suffix]) < 1)
        {
            return `${milliseconds.toFixed(3)} ${suffix}`;
        }
        milliseconds /= suffixes[suffix];
    }
}

function toggle()
{
    if(running)
    {
        document.querySelector("[name=run]").innerHTML = "Run";
        running = false;
        duration_runtime += new Date() - time_runtime_start;
        return;
    }

    bits = elements.bits.value;
    channels = elements.channels.value;
    canvas.width = elements.resolution_x.value;
    canvas.height = elements.resolution_y.value;
    if(canvas.width > document.querySelector("#all_images").clientWidth)
    {
        document.querySelector("#all_images").style.imageRendering = "auto";
    }
    else
    {
        document.querySelector("#all_images").style.imageRendering = "pixelated";
    }
    imagedata = context.createImageData(canvas.width, canvas.height);

    const bits_required = bits * (canvas.width * canvas.height) * channels;

    if(bits_required >= 1024)
    {
        console.error(`Image would require too many bits (${bits_required} >= 1024).`);
        return;
    }

    maxindex = BigInt(((2 << (bits - 1)) ** (canvas.width * canvas.height)) ** channels);
    document.querySelector("#combinations").innerHTML = Number(maxindex);

    document.querySelector("[name=run]").innerHTML = "Pause";
    running = true;
    time_runtime_start = new Date();
    run();
}

function update_stats(percentage, time_remaining, iterations, duration_runtime)
{
    document.querySelector("#percentage").innerHTML = percentage.toFixed(3);
    document.querySelector("#combination").innerHTML = imageindex;
    document.querySelector("#remaining").innerHTML = time_suffix(time_remaining);
    document.querySelector("#iterations").innerHTML = iterations.toFixed(3);
    document.querySelector("#runtime").innerHTML = time_suffix(duration_runtime);
}

function run()
{
    if(imageindex >= maxindex)
    {
        imageindex = BigInt(0);
        toggle();
        return;
    }

    parse_index(imagedata, imageindex, bits, channels);
    context.putImageData(imagedata, 0, 0);

    time_iteration_average = (new Date() - time_runtime_start + duration_runtime) / Number(imageindex);
    time_remaining = time_iteration_average * (Number(maxindex) - Number(imageindex));

    imageindex++;
    if(running)
    {
        requestAnimationFrame(run);
        update_stats(
            100 * Number(imageindex) / Number(maxindex),
            time_remaining,
            1000 / time_iteration_average,
            new Date() - time_runtime_start + duration_runtime
        );
    }
}

function reset_canvas()
{
    if(running)
    {
        toggle();
    }
    imageindex = BigInt(0);

    canvas.width = elements.resolution_x.value;
    canvas.height = elements.resolution_y.value;
    imagedata = context.createImageData(canvas.width, canvas.height);
    duration_runtime = 0;
    update_stats(0, 0, 0, 0);
}

function generate_all(canvas_id)
{
    if(running)
    {
        toggle();
        reset_canvas();
    }

    const elements = document.querySelector("[name=configure]").elements;
    const resolution_x = elements.resolution_x.value;
    const resolution_y = elements.resolution_y.value;
    const bits = elements.bits.value;
    const channels = 1;
    const mask = (2 ** bits) - 1;
    const maxindex = ((2 << (bits - 1)) ** (resolution_x * resolution_y)) ** channels;

    canvas.width = Math.round(Math.sqrt(maxindex)) * resolution_x;
    canvas.height = Math.round(Math.sqrt(maxindex)) * resolution_y;
    if(canvas.width > document.querySelector("#all_images").clientWidth)
    {
        document.querySelector("#all_images").style.imageRendering = "auto";
    }
    else
    {
        document.querySelector("#all_images").style.imageRendering = "pixelated";
    }
    const imagedata = context.createImageData(canvas.width, canvas.height);
    document.querySelector("#combinations").innerHTML = Number(maxindex);

    let x, y, pixelindex, colorindex, gray;
    imageindex = BigInt(0);

    let time_iteration_start = new Date();
    for(blit_y = 0; blit_y < Math.round(Math.sqrt(maxindex)); ++blit_y)
    {
        for(blit_x = 0; blit_x < Math.round(Math.sqrt(maxindex)); ++blit_x)
        {
            colorindex = 0
            for(y = 0; y < resolution_y; ++y)
            {
                for(x = 0; x < resolution_x; ++x)
                {
                    pixelindex = ((blit_y * resolution_y + y) * canvas.width + (blit_x * resolution_x + x)) * 4;
                    gray = 0xff * ((Number(imageindex) >> (bits * colorindex)) & mask) / mask;
                    imagedata.data[pixelindex+0] = gray;
                    imagedata.data[pixelindex+1] = gray;
                    imagedata.data[pixelindex+2] = gray;
                    imagedata.data[pixelindex+3] = 0xff;
                    colorindex++;
                }
            }
            imageindex++;
            if(imageindex >= maxindex)
            {
                break;
            }
        }
    }
    context.putImageData(imagedata, 0, 0);
    update_stats(100, 0, 0, new Date() - time_iteration_start);
    imageindex = BigInt(0);
}

function init()
{
    canvas = document.querySelector("#all_images");
    context = canvas.getContext("2d");
    elements = document.querySelector("[name=configure]").elements;
}
</script>
</head>
<body onload="init();">
<div class="content">
    <h1>All images</h1>
    <div class="image">
        <canvas id="all_images" width="100" height="100"></canvas>
    </div>
    <div class="configuration">
        <h2>Configuration</h2>
        <form name="configure" onsubmit="run(event);">
        <ul>
            <li><label for="resolution_x">Resolution x</label> <input name="resolution_x" type="text" value="3" size="5"/></li>
            <li><label for="resolution_y">Resolution y</label> <input name="resolution_y" type="text" value="3" size="5"/></li>
            <li><label for="bits">Color bit depth</label>
                <select name="bits">
                    <option value="1">1 (2 colors/channel)</option>
                    <option value="2">2 (4 colors/channel)</option>
                    <option value="3">3 (8 colors/channel)</option>
                    <option value="4">4 (16 colors/channel)</option>
                    <option value="5">5 (32 colors/channel)</option>
                    <option value="6">6 (64 colors/channel)</option>
                    <option value="7">7 (128 colors/channel)</option>
                    <option value="8">8 (256 colors/channel)</option>
                </select>
            </li>
            <li><label for="channels">Channels</label>
                <select name="channels">
                    <option value="1">1 (Grayscale)</option>
                    <option value="3">3 (RGB)</option>
                </select>
            </li>
        </ul>
        <button type="button" onclick="toggle();" name="run">Run</button>
        <button type="button" onclick="reset_canvas();">Reset</button>
        <button type="button" onclick="generate_all();" name="all">Generate all</button>
        </form>
        <h2>Statistics</h2>
        <ul>
            <li>Combination: <span id="combination">0</span> / <span id="combinations">0</span></li>
            <li>Progress: <span id="percentage">0</span>%</li>
            <li>Remaining time: <span id="remaining">0 milliseconds</span></li>
            <li>Average speed: <span id="iterations">0</span> it/s</li>
            <li>Total runtime: <span id="runtime">0 milliseconds</span></li>
        </ul>
    </div>
    <div class="source"><a href="https://github.com/Nurgak/all-images">Source</a></div>
</div>
</body>
</html>